{"ast":null,"code":"var _jsxFileName = \"/home/dan/Documents/Untitled Folder/361Project1-master/client/src/components/InvitationList.jsx\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport React, { useEffect, useState } from 'react';\nimport { useChatChannel, useChatContext } from 'stream-chat-react'; // Column flex box\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar channelStyle = {\n  display: \"flex\",\n  flexDirection: \"column\",\n  height: \"100%\"\n}; // style for the heade, justify content space between sets paragraphs oppostie\n\nvar headerStyle = {\n  display: \"flex\",\n  alignItems: \"center\",\n  margin: \"0px 22px\",\n  justifyContent: \"space-between\"\n}; // Justify space here makes sure the name shows up on the left, and the invite icon shows up on the right\n// We soace styff apart with margin\n\nvar ListItemUserWrapper = {\n  display: \"flex\",\n  alignItems: \"center\",\n  margin: \"0px 22px\",\n  justifyContent: \"space-between\"\n}; // style for user list wrapper\n\nvar ListItemUserWrapperName = {\n  display: \"flex\",\n  alignItems: \"center\",\n  textAlign: \"left\"\n}; // style for the  user list invite box\n\nvar emptyCheck = {\n  height: \"32px\",\n  width: \"32px\",\n  border: \"2px solid black\",\n  borderRadius: \"15px\",\n  boxSizing: \"border-box\",\n  marginLeft: \"6px\",\n  cursor: 'pointer'\n}; // style for when the circle is checked for users, fill it green basically, swap your class names to do this, why we use\n// app css sometimes\n\nvar Checked = {\n  height: \"32px\",\n  width: \"32px\",\n  background: \"green\",\n  border: \"2px solid black\",\n  borderRadius: \"16px\",\n  boxSizing: \"border-box\",\n  marginLeft: \"6px\",\n  cursor: 'pointer'\n}; // Wrapper Component for the list, renders wrapped children to render list items in this component\n// basically we build the header, then render the children components under it\n\nfunction MasterList({\n  children\n}) {\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: channelStyle,\n    children: [/*#__PURE__*/_jsxDEV(\"p\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 62,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: headerStyle,\n      children: [/*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"Members\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 64,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"Group Invitation\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 65,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 63,\n      columnNumber: 13\n    }, this), children]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 61,\n    columnNumber: 9\n  }, this);\n} // Component to generate items appearing in the user list, we map users to it to build the list\n\n\n_c = MasterList;\n\nfunction ListItemUser({\n  user,\n  setCheckedUsers\n}) {\n  _s();\n\n  const [checked, setChecked] = useState(false);\n\n  function detectCheck() {\n    //If we detect a check for this item, we filter out this user from the list of checked users in the createChannel components state\n    if (checked == true) {\n      // Kind of weird, we pass our checked users a callback function, essentially, we just make sure to remove the checked user instead of all of them\n      setCheckedUsers(prevUsers => prevUsers.filter(prevUser => prevUser !== user.id));\n    } //else, we keep the previous list and add this user id to it (because if checked is false, were turning it on)\n    else {\n        setCheckedUsers(prevUsers => [...prevUsers, user.id]);\n      } //When clicking, we set checked to the opposite of what is currently checked\n\n\n    setChecked(!checked);\n  } // Return name or ID, render either the empty check or the filled in green box telling us the selection is active\n\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: ListItemUserWrapper,\n    onClick: detectCheck,\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: ListItemUserWrapperName,\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: user.name || user.id || \"User Information Error\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 95,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 94,\n      columnNumber: 13\n    }, this), checked ? /*#__PURE__*/_jsxDEV(\"div\", {\n      style: Checked\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 99,\n      columnNumber: 24\n    }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n      style: emptyCheck\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 99,\n      columnNumber: 54\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 93,\n    columnNumber: 9\n  }, this);\n} // userlist component, \n\n\n_s(ListItemUser, \"OiiR1BYWvMsLHMiD2uYkeM3TCO0=\");\n\n_c2 = ListItemUser;\n\nfunction InvitationList({\n  setCheckedUsers\n}) {\n  _s2();\n\n  // get client instance\n  const {\n    client\n  } = useChatContext(); // state for user list held by the client for the list we are generating\n\n  const [users, setUsers] = useState([]); // State for loading user list\n\n  const [loadingList, setloadingList] = useState(false); // needed for async requests in this instance, render the user list once after users returned\n\n  useEffect(() => {\n    async function getUserList() {\n      if (loadingList == true) {\n        return;\n      } //If we are already getting the list, don't keep trying to get it\n      //loading set to true for the try catch block, where we query users from stream chat \n\n\n      setloadingList(true); //Async call to the stream chat client, filter out our own user, set range of users\n\n      try {\n        // Query users from client, info at https://getstream.io/chat/docs/react/query_users/\n        // Basically, we don't want client id, and we limit to 10 users\n        const response = await client.queryUsers({\n          id: {\n            $ne: client.userID\n          }\n        }, // query users from stream chats current context, exclude the logged in user\n        {\n          limit: 10\n        }); //If response has entries, set users array to the response \n\n        if (response.users.length > 0) {\n          setUsers(response.users);\n        }\n      } catch (error) {\n        console.log(\"error!\");\n      }\n\n      setloadingList(false); // We have finished retreiving the user list into the use states, so we can \n      // remove the loading message\n    }\n\n    getUserList(); //empty array ensures use effect only runs after the first render is detected. Use effects usually run again when list here changes\n  }, []); //return the master list component wrapping a list item generated for ever user present in the users state array\n\n  return /*#__PURE__*/_jsxDEV(MasterList, {\n    children: loadingList ? /*#__PURE__*/_jsxDEV(\"div\", {\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Loading Invitation Page, please wait\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 149,\n        columnNumber: 13\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 148,\n      columnNumber: 9\n    }, this) : users.map(user => /*#__PURE__*/_jsxDEV(ListItemUser, {\n      user: user,\n      setCheckedUsers: setCheckedUsers\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 153,\n      columnNumber: 17\n    }, this))\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 145,\n    columnNumber: 5\n  }, this);\n}\n\n_s2(InvitationList, \"+y6S49wuapTmrsoPes1i26n50Qo=\", false, function () {\n  return [useChatContext];\n});\n\n_c3 = InvitationList;\nexport default InvitationList;\n\nvar _c, _c2, _c3;\n\n$RefreshReg$(_c, \"MasterList\");\n$RefreshReg$(_c2, \"ListItemUser\");\n$RefreshReg$(_c3, \"InvitationList\");","map":{"version":3,"sources":["/home/dan/Documents/Untitled Folder/361Project1-master/client/src/components/InvitationList.jsx"],"names":["React","useEffect","useState","useChatChannel","useChatContext","channelStyle","display","flexDirection","height","headerStyle","alignItems","margin","justifyContent","ListItemUserWrapper","ListItemUserWrapperName","textAlign","emptyCheck","width","border","borderRadius","boxSizing","marginLeft","cursor","Checked","background","MasterList","children","ListItemUser","user","setCheckedUsers","checked","setChecked","detectCheck","prevUsers","filter","prevUser","id","name","InvitationList","client","users","setUsers","loadingList","setloadingList","getUserList","response","queryUsers","$ne","userID","limit","length","error","console","log","map"],"mappings":"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","sourcesContent":["import React, {useEffect, useState} from 'react'\nimport {useChatChannel, useChatContext} from 'stream-chat-react'\n\n// Column flex box\nvar channelStyle = {\n    display: \"flex\",\n    flexDirection: \"column\",\n    height: \"100%\"\n  };\n// style for the heade, justify content space between sets paragraphs oppostie\n  var headerStyle={\n    display: \"flex\",\n    alignItems: \"center\",\n    margin: \"0px 22px\",\n    justifyContent: \"space-between\"\n  };\n\n// Justify space here makes sure the name shows up on the left, and the invite icon shows up on the right\n// We soace styff apart with margin\n  var ListItemUserWrapper={\n    display: \"flex\",\n    alignItems: \"center\",\n    margin: \"0px 22px\",\n    justifyContent: \"space-between\"\n  };\n  // style for user list wrapper\n  var ListItemUserWrapperName={\n    display: \"flex\",\n    alignItems: \"center\",\n    textAlign: \"left\"\n  };\n\n  // style for the  user list invite box\n  var emptyCheck = {\n    height: \"32px\",\n    width: \"32px\",\n    border: \"2px solid black\",\n    borderRadius: \"15px\",\n    boxSizing: \"border-box\",\n    marginLeft: \"6px\",\n    cursor:'pointer'\n  }\n  // style for when the circle is checked for users, fill it green basically, swap your class names to do this, why we use\n  // app css sometimes\n  var Checked = {\n    height: \"32px\",\n    width: \"32px\",\n    background: \"green\",\n    border: \"2px solid black\",\n    borderRadius: \"16px\",\n    boxSizing: \"border-box\",\n    marginLeft: \"6px\",\n    cursor:'pointer'\n  }\n\n// Wrapper Component for the list, renders wrapped children to render list items in this component\n// basically we build the header, then render the children components under it\nfunction MasterList({children} ){\n    \n    return(\n        <div style={channelStyle}>\n            <p></p>\n            <div style={headerStyle}>\n                <span>Members</span>\n                <span>Group Invitation</span>\n            </div>\n             {/* Our wrapped ListItemUser components*/}\n            {children}\n        </div>\n    )\n}\n\n// Component to generate items appearing in the user list, we map users to it to build the list\nfunction ListItemUser({ user, setCheckedUsers}){\n    const [checked, setChecked] = useState(false)\n    function detectCheck(){\n        //If we detect a check for this item, we filter out this user from the list of checked users in the createChannel components state\n        if(checked == true){\n            // Kind of weird, we pass our checked users a callback function, essentially, we just make sure to remove the checked user instead of all of them\n            setCheckedUsers((prevUsers) => prevUsers.filter((prevUser) => prevUser !== user.id))\n        }\n\n        //else, we keep the previous list and add this user id to it (because if checked is false, were turning it on)\n        else{\n            setCheckedUsers((prevUsers) => [...prevUsers, user.id])\n        }\n\n        //When clicking, we set checked to the opposite of what is currently checked\n        setChecked(!checked)\n    }\n    // Return name or ID, render either the empty check or the filled in green box telling us the selection is active\n    return(\n        <div style={ListItemUserWrapper} onClick={detectCheck}>\n            <div style={ListItemUserWrapperName}>\n                <p>\n                    {user.name || user.id || \"User Information Error\"}\n                </p>\n            </div>\n            {checked ? <div style={Checked}></div> : <div style={emptyCheck}></div>}\n        </div>\n    )\n}\n\n// userlist component, \nfunction InvitationList({setCheckedUsers}){ \n    // get client instance\n    const {client} = useChatContext()\n    // state for user list held by the client for the list we are generating\n    const [users, setUsers] = useState([]);\n    // State for loading user list\n    const [loadingList, setloadingList] = useState(false);\n\n    // needed for async requests in this instance, render the user list once after users returned\n    useEffect(()=> {\n        async function getUserList(){\n            if(loadingList == true) {return} //If we are already getting the list, don't keep trying to get it\n            //loading set to true for the try catch block, where we query users from stream chat \n            setloadingList(true) \n            \n            //Async call to the stream chat client, filter out our own user, set range of users\n            try {\n                // Query users from client, info at https://getstream.io/chat/docs/react/query_users/\n                // Basically, we don't want client id, and we limit to 10 users\n                const response = await client.queryUsers(\n                    {id: { $ne :client.userID }}, // query users from stream chats current context, exclude the logged in user\n                    {limit: 10}\n                );\n                    //If response has entries, set users array to the response \n                if(response.users.length > 0) {\n                    setUsers(response.users)\n                } \n            } catch (error) {\n                console.log(\"error!\")\n\n            }\n            setloadingList(false) // We have finished retreiving the user list into the use states, so we can \n            // remove the loading message\n        }\n        getUserList()\n    //empty array ensures use effect only runs after the first render is detected. Use effects usually run again when list here changes\n    },[])\n\n    //return the master list component wrapping a list item generated for ever user present in the users state array\n    return (\n    <MasterList>\n        {/* We will map every user in the users state into the ListItemUser components so that we can build a list of users*/}\n        {loadingList ? \n        <div>\n            <p>Loading Invitation Page, please wait</p>\n            \n        </div> : \n            (users.map((user)=>(\n                <ListItemUser user={user} setCheckedUsers={setCheckedUsers}/>\n            ))\n            )}\n    </MasterList>\n\n    )\n}\n\nexport default InvitationList\n"]},"metadata":{},"sourceType":"module"}